---
title: JavaScript的提升
date: 2024-05-1 18:19:21
tags: 提升
---
[TOC]
# JavaScript的提升
## 执行顺序问题
我们在JavaScript初期的学习过程中，有相当的教科书以及老师会告诉我们JavaScript是由上到下逐行执行的，这在大多数情况下都是正确的，但是凡事都有例外，如下：
```
a = 2;
var a;
console.log(a);
```
上面的代码，很多人可能会先入为主认为是undefined，因为`var a`声明在`a = 2`之后，自然而然会认为变量被重新赋值了，因此认为是undefined，然而事实输出结果是2.
再考虑如下代码：
```
console.log(a);
var a = 2;
```

由上一个代码块表现出来异于自上而下的特性，在这影响下又回回到上一个误区，认为这里的输出为2，还有人会认为这里会报错，然而这个代码块的输出是undefined
因此我们此处面临着类似于世界上是先有鸡还是先有蛋的怪圈。
## 编译器的影响
正确的思考思路是，包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。
当我们看到`var a = 2;`时，可能下意识认为这是一个声明，但是JS编译器实质上会将其看成两个声明，即：`var a;` 和 `a=2` ,第一个声明是在编译阶段进行的，第二个赋值则在原地等待执行阶段。
我们的第一个代码段会这样进行处理：
```
var a;
a = 2;
console.log(a);
```
第一部分是编译，第二部分是执行。
我们的第二个代码段会这样进行处理：
```
var a;
console.log(a);
a = 2;
```
这样的过程，就像变量和函数声明把它们从代码出现的位置移动到了最上面。这个过程被叫做提升。

**只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成相当严重的破坏**

## 对函数的声明
```
foo();
function foo(){
console.log(a);
var a = 2;
}
```
有了上面对于变量的提升，相比很容易就能联想到这里的函数`foo()`应该也是能提升的，因此第一行中的调用可以正常执行。
值得注意的是，每一个作用于都会进行提升操作，就如我们正在讨论的`foo()`函数内部也对`var a`进行提升，当然不是提升到整个程序的最上方，更贴切的说这里的提升是限定在作用域内的。因此会被理解为下面的代码：
```
function foo(){
    var a;
    console.log(a);//undefined
    a = 2;
}
foo();
```
**实践是检验真理的唯一标准，没有任何教科书会确保自己不会出错，实践出真知！**
可以看到上面代码块中，函数声明被提升了，但是函数表达式却不会被提升。再看下面的代码：
```
foo();//这里不是ReferenceError,而是TypeError!
var foo = function bar(){
    //...
}
```
上面程序中的变量标识符`foo()`，被提升分配给了所在作用域（此处是全局作用域），所以并不导致ReferenceError，但是foo()并没有被赋值，因为这里是函数表达式而不是函数声明。此处foo()调用了undefined，从而导致非法操作，因此报错TypeError。
即便是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用：
```
foo();
bar():
var foo = function bar(){
    //...
}
```
该代码经过提升后，实际会被理解为以下形式：
```
var foo;
foo();
bar();
foo = function(){
    var bar = ...
    //...
}
```
ps：各位可能对于ReferenceError/TypeError的意义不是很明确，因此下面进行补充。
#### ReferenceError/TypeError
~~这些都是较为基础的知识点，因此这里不会特别详细。~~
##### Reference(引用错误)
当尝试访问一个未被声明或定义的变量时发生。
因为在JavaScript中，必须在使用变量之前声明=>var、let、const
当然，我们上文也对声明提升问题进行了讨论。
##### TypeError(类型错误)
当尝试对错误类型的值执行不被允许的操作时发生。通常表明在操作中使用了不兼容的数据类型。

## 函数优先
经过我们上面的讨论，发现不论是函数声明还是变量声明都会提升。需要补充的是，函数首先被提升然后才是变量，参考如下：
```
foo()   // 1
var foo;
function foo(){
    console.log(1);
}
foo = function(){
    console.log(2);
}
```
上面的输出是1而不是2。在引擎的理解下，会整理成如下形式：
```
function foo(){
    console.log(1);
}
foo();
foo = function(){
    console.log(2);
}
```
函数声明会被提升到普通变量，比如：`var foo`尽管出现在`function foo()...`之前，但是由于是重复的声明，因此被忽略。
重复的`var`声明会被忽略，但出现在后面的函数声明依然可以覆盖前面的，参考下面的代码：
```
foo();  // 3
function foo(){
    console.log(1);
}
var foo = function(){
    console.log（2）；
}
function foo(){
    console.log(3);
}
```
在同一个作用域中重复定义是非常糟糕的，可能会导致一些特别奇怪无法预测的问题=>这些听起来就是无用的学院派理论，但是非常需要注意。
**无论如何，光看不练始终是没有用的**
